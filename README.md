# OOP-tasks
This work made in 2021 for OOP course in SPbPu
# Tasks description

## А1 Геометрические фигуры
Все числовые данные в этой работе должны быть представлены значениями с плавающей запятой.
1. Создать файл base-types.hpp, содержащий определения следующих структур:

- point_t, представляющую собой точку на плоскости, координаты должны храниться в полях x и y.

- rectangle_t, описывающую прямоугольник шириной width и высотой height с центром в точке pos.

2. Создать файл shape.hpp, содержащий определение абстрактного класса Shape. Этот класс должен предоставлять следующие методы:
getArea вычисление площади
getFrameRect получение ограничивающего прямоугольника для фигуры (см. типы из предыдуще-
го пункта), стороны ограничивающего прямоугольника всегда параллельны осям
move перемещение центра фигуры, 2 варианта: в конкретную точку и в виде смещений по осям абсцисс и ординат
3. Реализовать классы Rectangle и Circle в файлах rectangle.hpp, rectangle.cpp, circle.hpp и circle.cpp соответственно.
4. Продемонстрировать правильную работу классов простой программой. Демонстрация должна вклю- чать полиморфное применение классов.
Дополнительное задание
Добавить поддержку треугольников. В качестве центра треугольника здесь и далее следует использо- вать центр тяжести, так как его вычисление наиболее просто.

## A2 Масштабирование фигур
1. В виде исключения! Все дальнейшие работы должны следовать правилам оформления работ и не содержать скопированного кода, за исключением набора тестов. Скопируйте исходные тексты за- дания 1.
2. Перенесите классы фигур в отдельное пространство имен. Имя этого пространства должно быть выбрано совпадающим с фамилией студента в нижнем регистре (соответственно, оно совпадает с частью имени каталога с работами до точки), например, для Петрова Ивана каталог будет назы- ваться petrov.ivan, соответственно, имя пространства имен — petrov. Это пространство имен должно сохраняться для всех оставшихся работ в этом семестре.
3. Добавить в класс фигуры метод scale(), осуществляющий изотропное масштабирование фигуры относительно ее центра с указанным коэффициентом.
Если в первой работе был реализован треугольник, масштабирование необходимо реализовать и для него.
4. Написать тесты, проверяющие:
- неизменность ширины и высоты, а также площади фигуры при перемещениях; ∙ квадратичное изменение площади фигуры при масштабировании;
- наличие и обработку некорректных параметров в функциях;
Для написания тестов необходимо создать файл test-main.cpp, в котором реализовать тесты.
Созданная ранее демонстрационная программа должна быть доработана для демонстрации новых возможностей.
 
## A3 Составные фигуры
Расширить реализацию работы 2 путем добавления класса CompositeShape, хранящего список из про- извольных фигур внутри массива. В этой работе не допускается использование стандартных контейне- ров, необходимо самостоятельно реализовать хранение множества фигур на базе динамического массива. Класс должен быть размещен в файлах composite-shape.hpp и composite-shape.cpp.

Написать набор тестов, проверяющий корректную работу созданного класса. Необходимо помнить, что может потребоваться реализация дополнительных специальных методов в классе для обеспечения корректной работы.

Для CompositeShape масштабирование и перемещение работают относительно центра этого объекта, за который принимается центр ограничивающего прямоугольника.

Созданная ранее демонстрационная программа должна быть доработана для демонстрации новых возможностей.

## A4 Обработка фигур
Расширить реализацию работы 3:
1. Добавить поддержку вращения фигур на заданный угол в градусах, положительное направление —
против часовой стрелки, центр поворота совпадает с центром фигуры. Необходимо помнить, что ограничивающий прямоугольник сохраняет параллельность сторон осям координат, а поворот CompositeShape также содержит перемещение элементов. Метод должен называться rotate().

Тем, кто реализовывал в первой работе поддержку треугольников, необходимо поддержать вращение треугольников тоже.

2. Написать разбиение списка фигур (Rectangle, Circle, CompositeShape и, если был реализован, Triangle), представленного в виде единой фигуры, по слоям в порядке добавления:
- фигуры, которые не перекрываются ограничивающими прямоугольниками, находятся на одном слое;
- фигура, перекрывающаяся с другой, находится на следующем слое если она указана в списке после той фигуры, которую она перекрывает;
- составные фигуры, добавленные в фигуру, подвергнутую разбиению, необходимо рассматривать как единое целое и обрабатывать ее ограничивающий прямоугольник, а не ее составляющие.

Например, фигуры указаны в следующем порядке:
- красный прямоугольник 
- зеленый круг
- синий прямоугольник

Разбиение по слоям выглядит так:

- первый слой 2 прямоугольника, так как они не перекрываются, а круг закрывает красный пря- моугольник

- второй слой зеленый круг, так как он указан после красного прямоугольника и перекрывается с ним.

Результаты разбиения представить в виде матрицы, где строки представляют собой слои, в кото- рых указаны фигуры. Матрицу реализовать самостоятельно на базе динамической памяти, данные должны храниться в 1 блоке (недопустимо создавать массив указателей на слои). Количество строк соответствует количеству слоев, количество столбцов — максимальному количеству фигур в одном слое.

3. Реализовать тесты, демонстрирующие корректную работу функции разбиения.
Созданная ранее демонстрационная программа должна быть доработана для демонстрации новых возможностей.

## B1 Векторы
Необходимо выполнить все задания.

Работа должна быть выполнена в виде 1 исполняемого файла, принимающего параметры следующим образом:

`$ ./lab number [args]`

number представляет собой номер пункта, например, 1 или 2. В качестве args передаются дополни- тельные параметры, зависящие от пункта.
1. Напишите алгоритм сортировки (любой простейший) коллекции целых чисел, полученных из стан- дартного ввода, так, чтобы:

(a) сортировка вектора проводилась с использованием оператора operator [];

(b) сортировка вектора проводилась с использованием метода std::vector<>::at().

(c) сортировка односвязного списка осуществлялась при помощи итераторов [Мар, разд. 16.3.1].

Окончанием ввода необходимо считать состояние End Of File (EOF, конец файла).

Программа должна запускаться с дополнительным параметром, в зависимости от значения которого, сортировка производится по возрастанию или убыванию:
ascending по возрастанию; descending по убыванию.

Выведите на стандартный вывод отсортированные коллекции, разделяя элементы пробелами. Кол- лекция, отсортированная каждым видом доступа, должна быть выведена на 
отдельной строке. Например,

```
$ cat data
4321
$ ./lab 1 ascending < data 1234
1234
1234
```
2. Прочитайте во встроенный массив C содержимое текстового файла, имя которого передано в пара- метре. Скопируйте данные в вектор одной строкой кода (без циклов и алгоритмов Standard Template Library (STL)).
Выведите на стандартный вывод содержимое вектора.
3. Напишите программу, сохраняющую в векторе целые числа, полученные из стандартного ввода (окончанием ввода является число 0). Используя итераторы, удалите все элементы, которые делятся на 2 (не используя алгоритмы STL), если последнее число 1. Если последнее число 2, добавьте после каждого числа, которое делится на 3, три единицы, также используя итераторы. Все изменения должны осуществляться при помощи итераторов и без использования индексов.

Выведите на стандартный вывод полученную после преобразований коллекцию чисел, разделяя чис- ла пробелом.
4. Напишите функцию void fillRandom(double * array, int size), заполняющую массив случай- ными значениями в интервале от −1.0 до +1.0. Заполните с помощью заданной функции вектор заданного размера и отсортируйте его содержимое (с помощью любого разработанного ранее алго- ритма, модифицированного для сортировки как целых, так и действительных чисел).

Выведите на стандартный вывод исходную и отсортированную коллекции на отдельных строках, разделяя элементы пробелами.

Программа должна запускаться с 2 дополнительными параметрами:
- направление сортировки (ascending или descending);
- размер вектора. Например,
     
     ```
     $./lab 4 ascending 3
     0.5 0.8 0.4
     0.4 0.5 0.8
     ```
## B2 Текст
Разработать программу, которая должна сделать следующее:
1. Прочитать текст со стандартного ввода, который может содержать:
(a) Слова — состоят из латинских строчных и заглавных букв, а также дефиса «-», длина слова должна быть не более 20 символов.

(b) Слова могут заканчиваться дефисом, но не могут с него начинаться.

(c) Знаки препинания — «.», «,», «!», «?», «:», «;», «---» (3 дефиса, эквивалент тире). Знаки пре- пинания не могут идти друг за другом, за исключением тире: перед тире может встречаться запятая. Допускается обработка и других знаков препинания в соответствии с тем, как их понимают настройки пользователя.

(d) Числа, состоящие из цифр и десятичного разделителя, а также опционального знака числа («+» и «-»), разделение групп цифр не используется, длина числа — не более 20 символов.

(e) Пробельные символы — пробел, табуляция, символ новой строки.

(f) Текст не может начинаться с пунктуации.

2. Отформатировать текст следующим образом:

(a) Не должно быть пробельных символов, отличных от пробела.

(b) Не должно идти подряд более одного пробела.

(c) Между словом и знаком препинания не должно быть пробела, за исключением тире, которое выделяется пробелами с обеих сторон.

(d) После знака препинания всегда должен идти пробел.

(e) Не допускается перенос тире на следующую строку.

3. Преобразовать полученный текст в набор строк, каждая из которых содержит целое количество слов и чисел (каждый элемент должен целиком находиться в строке) и ее длина не превышает число символов, задаваемых параметром. При этом каждая строка должна содержать максимальное число слов, не должна заканчиваться пробельными символами и начинаться со знаков препинания.

4. Вывести полученный набор строк на стандартный вывод.
Программа должна принимать необязательный аргумент --line-width с параметром, указывающим дли- ну строки в символах. Если параметр не указан, длина строки принимается в 40 символов. Таким образом, программа может быть запущена:

`$ ./lab --line-width 70`

Это дает длину строки в 70 символов. Или так: 

`$ ./lab`

Что дает значение по умолчанию в 40 символов.

Всю дополнительную информацию, в частности, десятичный разделитель, необходимо получить из настроек пользователя при помощи стандартной библиотеки1.

## B3 Последовательности

Необходимо выполнить все задания.

Как и задание 1, это задание должно быть выполнено в виде консольной программы, принимающей в качестве единственного параметра номер пункта задания.
конец

Ниже приведен интерфейс класса очереди с приоритетами, который функционирует следующим об- разом:
1. В очередь могут быть добавлены элементы, каждому элементу при добавлении присваивается один из трех уровней приоритета (low, normal, high).
2. Элементыизочередиизвлекаютсявсоответствиисихприоритетами(сначалаизвлекаютсяэлементы с приоритетом high, потом normal, потом low), элементы с одинаковыми приоритетами извлекаются из очереди в порядки их поступления.
3. В очереди также может происходить операция акселерации –– все элементы с приоритетом low, находящиеся в момент акселерации в очереди, увеличивают свой приоритет до high и «обгоняют» элементы с приоритетом normal.
Ниже приведен интерфейс этого класса:
```
typedef enum 
  {
    LOW,
    NORMAL,
    HIGH
  } ElementPriority; 

typedef struct 
{
  std::string name;
} QueueElement;

class QueueWithPriority
{
  QueueWithPriority();
  
  ~QueueWithPriority();
  
  void PutElementToQueue(const QueueElement & element,
      ElementPriority priority);
      
  QueueElement GetElementFromQueue();
  
  void Accelerate();
};
```
1. Переработайте класс так, чтобы он мог обрабатывать элементы произвольного типа.
2. Исправьте ошибки в интерфейсе, обеспечив безопасный интерфейс для применения в большом про- мышленном проекте.
3. Реализуйте исправленный класс, используя std::list<> или std::deque<>. Объясните выбор.
4. Реализуйте программу, обрабатывающую очередь из строк по командам, принимаемым со стандарт- ного ввода. Каждая строка содержит ровно одну команду. Должны поддерживаться следующие команды:
- add <priority> <data>
Добавление элемента в очередь с приоритетом <priority> (low, normal или high).
- get
Получение очередного элемента в очереди в соответствии с приоритетом, в стандартный вывод печатаются данные элемента. В случае, если очередь пуста, выводится строка <EMPTY>.
- accelerate
Изменение приоритета элементов очереди.

В случае получения неподдерживаемой или неправильно сформированной команды в стандартный вывод печатается <INVALID COMMAND>.

Разработайте программу, которая:
1. Заполняет std::list< int > значениями от 1 до 20 со стандартного ввода, список может содержать
от 0 до 20 значений.
2. Выводит содержимое списка в следующем порядке: первый элемент, последний элемент, второй
элемент, предпоследний элемент, третий элемент и т.д.
3. В случае получения некорректных данных программа должна выводить сообщение об ошибке в
стандартный поток ошибок и завершаться с кодом 1.
  
Например если список содержит:

12345678

то вывод будет иметь вид

18273645

Подсказка: можно использовать рекурсию и двунаправленные итераторы.
## B4 Итераторы
Выполните все задания в виде программы, принимающей в качестве первого параметра номер пункта: 1

Напишите программу-«телефонную книжку», состоящую из 2-х компонентов:
1. Компонент-книжка.

Записи (имя и телефон) должны хранится в каком-либо контейнере из STL. Программа должна поддерживать следующие операции:
- Просмотр текущей записи.
- Переход к следующей записи.
- Переход к предыдущей записи.
- Вставка записи перед/после просматриваемой. ∙ Замена просматриваемой записи.
- Вставка записи в конец базы данных.
- Переход вперед/назад через 𝑛 записей.

Необходимо учесть, что клиентскому коду может быть необходимо иметь ссылки на разные записи в книжке одновременно.

Помните, что после вставки и удаления элемента итераторы могут стать недействительными.
  
Телефон представляется в виде последовательности цифр без разделителей.
2. Пользовательский интерфейс, принимающий команды со стандартного ввода по одной на строке и выводящий результаты на стандартный вывод. Должны поддерживаться следующие команды:
- add number "name"

  Добавление записи в конец. Кавычки не являются частью имени. Требуется учесть, что имя может содержать кавычки и обратную черту, (предваренные обратной косой чертой, как в литералах C++ [Мар, табл. 3.2]), но не может содержать новую строку (например, "Name \"Nick\"Surname").
- store mark-name new-mark-name

  Сохраняет текущую позицию закладки с именем mark-name как новую закладку с именем new-
mark-name. Имя содержит только символы английского алфавита, цифры и знак «минус». По- сле запуска программы доступна 1 закладка с именем current.
- insert before mark-name number "name" 
  
 Добавление записи перед закладкой mark-name.
- insert after mark-name number "name" 
  
  Добавление записи после закладки mark-name.
- delete mark-name

  Удаление записи, на которую указывает закладка mark-name. После удаления закладка указы- вает на следующий элемент.
- show mark-name

  Показ записи, на которую указывает закладка mark-name. Если записей нет (книжка пустая),
выводится <EMPTY>. Вывод должен быть выполнен без служебных последовательностей, в частности, строка из примера команды add должна быть выведена как Name "Nick"Surname.
- move mark-name steps

  Перемещение закладки mark-name на steps элементов. Если steps положительно, то закладка пе- ремещается вперед, иначе — назад. Также в качестве steps могут быть использованы ключевые слова first и last, означающие первую и последнюю запись соответственно. Если параметр steps не число и не зарезервированное ключевое слово, в стандартный вывод выводится сообщение <INVALID STEP>.

  Работа пользовательского интерфейса заканчивается при наступлении EOF или ошибки ввода- вывода. В случае ошибки, код возврата должен быть равен 2.

  В случае получения неправильной команды необходимо вывести в стандартный вывод строку <INVALID COMMAND> и продолжить работу.

  Если переданное имя закладки не существует в стандартный вывод выводится строка <INVALID BOOKMARK>.


  Реализуйте следующие классы:
- «Контейнер», который содержит значения факториала от 1! до 10!. Интерфейс класса должен включать в себя как минимум:
- - Конструктор по умолчанию.
- - Функцию получения итератора указывающего на первый элемент контейнера — begin().
- - Функцию получения итератора указывающего на элемент, следующий за последним — end().

  Доступ к элементам этого контейнера возможен только с помощью итераторов, возвращаемых функ- циями begin() и end().

  Контейнер не должен хранить в памяти свои элементы, они должны вычисляться при обращении к ним через итератор.
- Класс итератора для перечисления элементов этого контейнера, объекты этого класса возвращают- ся функциями begin() и end(). Итератор должен быть двунаправленным. Итератор должен быть совместимым с STL.

  Требования категории итератора должны быть выполнены.
- Выведите содержимое «контейнера» в 2 строки в стандартный вывод: первая строка в прямом на- правлении, вторая — в обратном при помощи std:copy(). Необходимо помнить, что предотвратить применение std::reverse_iterator<> в клиентском коде невозможно.
